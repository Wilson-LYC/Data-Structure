# 3-7-5 逆波兰表达式求值题解

## 题目

逆波兰表示法是一种将运算符（operator）写在操作数（operand）后面的描述程序（算式）的方法。举个例子，我们平常用中缀表示法描述的算式（1 + 2）*（5 + 4），改为逆波兰表示法之后则是1 2 + 5 4 + *。相较于中缀表示法，逆波兰表示法的优势在于不需要括号。

请输出以逆波兰表示法输入的算式的计算结果。

### 输入格式:

在一行中输入1个算式。相邻的符号（操作数或运算符）用1个空格隔开。

### 输出格式:

在一行中输出计算结果。

### 限制:

2≤算式中操作数的总数≤100

1≤算式中运算符的总数≤99

运算符仅包括“+”、“-”、“*”，操作数、计算过程中的值以及最终的计算结果均在int范围内。

### 输入样例1:

```in
4 3 + 2 -
```

### 输出样例1:

```out
5
```

### 输入样例2:

```in
1 2 + 3 4 - *
```

### 输出样例2:

```out
-3
```



## 题解

### 什么是逆波兰表达式

逆波兰表示法是一种将**运算符（operator）**写在**操作数（operand）**后面的描述程序（算式）的方法。

![逆波兰表示法图解](https://user-images.githubusercontent.com/61262980/161783916-e2d395b8-5e53-4e0f-b3cc-38ac8e85fb13.png)

输入样例2的人工计算

![输入样例2的人工计算](https://user-images.githubusercontent.com/61262980/161784352-5c92db6c-5fda-4f37-b415-bff6717e0b50.png)

### 我们要存储哪些数据
根据题目意思，我们需要存储的有数字和操作符号。利用小学二年级学过的知识，我们不难发现，在逆波兰表达式中，计算优先级越低的运算符越晚出现。换句话说，越晚出现的运算符，越晚计算。所以，在我们程序计算的时候，不需要考虑运算符优先级。越早出现的运算符优先级越高。综上所述，我们只需要存储数字就好了。

### 大概的思路
* 先读入一个字符串，将整个式子保存下面来。
* 从0位开始遍历到字符串尾
* 若当前字符是数字0-9的一个，则识别数字，识别完后入栈
* 若当前是运算符，从栈中取两个数字进行计算。结果有放回栈中。

### 代码详解
```c++
#include<iostream>
#include<stack>
#include<string.h>
using namespace std;
int main()
{
	stack<int>num;//创建 操作数 的栈
	string s;
	getline(cin,s);//输入逆波兰表达式
	int l=s.length(),i=0;
	while (i<=l-1)//从头到尾遍历字符串
	{
		//cout<<"i="<<i<<endl;
		if (s[i]>='0' && s[i]<='9')//发现是数字，开始识别
		{
			int new_num=0;
			while (s[i]>='0' && s[i]<='9')//只要当前还是数字，则继续识别数字
			{
				new_num=new_num*10+int(s[i])-48;
				i++;
			} 
			num.push(new_num);//得到的数字入栈
		}	
		else if (s[i]!=' ') //不是数字也不是空格，那就是运作符
		{
			int a,b,ans=0;
			a=num.top();//获得栈顶数字
			num.pop();//出栈
			b=num.top();//获得栈顶数字
			num.pop();//出栈
			switch (s[i])
			{
				case '+':
					ans=a+b;
					break;
				case '-':
					ans=b-a;
					break;
				case '*':
					ans=a*b;
					break;
				case '/':
					ans=b/a;
					break;
			}
			//cout<<a<<s[i]<<b<<"="<<ans<<endl; 
			num.push(ans);//将结果入栈，作为下一轮运算的操作数
		}
		i++;
	} 
	cout<<num.top();//运算完毕后，栈内剩余的就是最终结果了。
} 
```
